# 서로 연결되어있는 1덩어리들의 개수를 구하라

def solution(grid):
    def dfs(i, j):
        # 하나씩 따져봅시다.
        # 1. i < 0과 j < 0은 당연합니다.
        # 2. i >= len(grid) : i는 열 이터레이션입니다. 그러니 i는 grid의 길이, 열의 길이보다 커서는 안됩니다.
        # 3. j >= len(grid[0]) : j는 행 이터레이션입니다. 그러니 j는 각 행의 원소인 벡터의 길이보다 커서는 안됩니다.
        # 4. grid[i][j] != 1 : 탐색한 원소가 0인 경우를 나타냅니다. 0이 된다면 함수를 종료해야 하므로, return합니다.
        # 즉, 이 4가지 조건은 탐색에서 땅이 아닌 경우를 밟았을 때를 말하며 그 때 종료시킴을 명시합니다.
        # 동서남북 4방향으로 재귀하며 각각 뻗어가 연쇄적으로 탐색을 하는 도중, 0이 만난다면 이 if에 걸려 중지되게 됩니다.
        if i < 0 or \
                i >= len(grid) or \
                j < 0 or \
                j >= len(grid[0]) or \
                grid[i][j] != 1:
            return

        # 이건 이미 방문했던 곳을 0으로 설정하는 겁니다.
        grid[i][j] = 0

        # 4개 모두 입력해줍니다. 재귀는 뻗어나가며 연쇄적으로 이뤄집니다. 이미 0이거나 0인 곳에 다다를 경우 해당 재귀는 종료됩니다.
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)

    count = 0
    # 반복 횟수는 grid의 열의 갯수
    for i in range(len(grid)):
        # 그리고 다시 해당 행 내부에서 이터레이션을 겁니다.
        for j in range(len(grid[0])):
            # 해당 원소가 1인 경우 재귀합니다.
            if grid[i][j] == 1:
                dfs(i, j)
                # 재귀할게 없으면 1덩어리들으 모두 찾은 것이므로, 1을 답에 더해줍니다.
                count += 1
    print(count)
    return count


caseA = [
    [1, 1, 1, 1, 0],
    [1, 1, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 0, 0],
]

caseB = [
    [1, 1, 0, 0, 1],
    [1, 0, 0, 1, 0],
    [1, 1, 1, 0, 0],
    [0, 0, 0, 0, 1],
]

solution(caseB)
